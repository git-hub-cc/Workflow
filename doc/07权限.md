好的，这是对当前代码库中权限相关逻辑的详细说明。

系统的权限体系是一个多层次、职责分明的设计，结合了**认证**、**授权**和**数据范围**三个核心层面，以实现精细化的访问控制。

### 核心权限模型

权限模型基于以下几个核心实体：

*   **User (用户)**: 操作的执行者，拥有唯一的 ID。
*   **Role (角色)**: 权限的集合，如 "ADMIN"（管理员）、"USER"（普通用户）。一个用户可以拥有多个角色。
*   **Department (部门)**: 用户的组织归属，用于实现按部门的数据隔离和审批流。
*   **Menu (菜单)**: 前端界面的入口，与角色关联，决定了用户能看到和访问哪些功能页面。

---

### 第一层：认证 (Authentication) - “你是谁？”

系统首先需要确认操作者的身份。这部分由 Spring Security 和 JWT (JSON Web Token) 机制负责。

1.  **登录认证 (`AuthController`, `AuthService`)**:
    *   用户通过 `/api/auth/login` 接口，提供 `userId` 和 `password`。
    *   `AuthService` 调用 Spring Security 的 `AuthenticationManager` 进行认证。
    *   `AuthenticationManager` 委托给 `UserDetailsServiceImpl`，该服务根据 `userId` 从数据库加载 `User` 实体。
    *   Spring Security 自动使用 `PasswordEncoder` (在 `SecurityConfig` 中配置的 `BCryptPasswordEncoder`) 比较用户提交的密码和数据库中存储的加密密码。
    *   `UserDetailsServiceImpl` 还会检查用户的状态（`ACTIVE`, `INACTIVE`, `LOCKED`），如果账户状态异常，认证会失败并抛出相应的异常（如 `DisabledException`）。
    *   **全局异常处理**: `GlobalExceptionHandler` 会捕获这些认证异常（如 `BadCredentialsException`），并返回统一格式的、用户友好的 JSON 错误信息（例如 HTTP 401 "用户名或密码错误"）。

2.  **令牌管理 (`JwtService`, `JwtAuthFilter`)**:
    *   认证成功后，`JwtService` 会为用户生成一个包含其 `userId` 和过期时间的 JWT。
    *   此后的每个请求，客户端都必须在 `Authorization` 请求头中携带此 JWT (`Bearer <token>`)。
    *   `JwtAuthFilter` 是一个过滤器，它会在每个请求到达 Controller 之前拦截请求。
    *   它负责解析 JWT，验证其有效性，并从中提取 `userId`。
    *   然后，它再次使用 `UserDetailsServiceImpl` 加载用户信息，并将构建好的认证对象（`UsernamePasswordAuthenticationToken`）放入 `SecurityContextHolder` 中。
    *   这样，在整个请求处理周期内，系统随时都可以知道当前登录的用户是谁以及他拥有哪些角色。

---

### 第二层：授权 (Authorization) - “你能做什么？”

一旦确认了用户身份，系统就需要判断该用户是否有权执行请求的操作。这部分通过两种方式实现：URL 级别和方法级别。

1.  **URL 级别安全 (粗粒度控制)**:
    *   **配置文件**: `config/SecurityConfig.java`
    *   **机制**: 这是权限控制的第一道防线。它通过 `HttpSecurity` 定义了哪些 URL 路径可以被何种身份的用户访问。
    *   **核心规则示例**:
        *   **公开访问**: `/api/auth/**`, `/h2-console/**` 等路径对所有人开放 (`.permitAll()`)。
        *   **仅限认证用户**: `/api/menus/my-menus`, `/api/files/**` 等路径要求用户必须登录 (`.authenticated()`)。
        *   **仅限管理员**: 所有 `/api/admin/**` 下的路径，以及一些高权限操作（如 `/api/forms/import-word`），都明确要求用户必须拥有 "ADMIN" 角色 (`.hasRole("ADMIN")`)。
        *   **安全修复**: 一个重要的例子是 `/api/workflows/users` 接口，它用于在流程设计器中选择用户。该接口的权限已从 `.authenticated()` 收紧为 `.hasRole("ADMIN")`，以防止普通用户获取到系统内的全量用户列表，避免了信息泄露风险。

2.  **方法级别安全 (细粒度控制)**:
    *   **启用注解**: `SecurityConfig` 中的 `@EnableMethodSecurity(prePostEnabled = true)` 开启了方法级别的安全注解。
    *   **机制**: 使用 `@PreAuthorize` 注解直接在 Controller 的方法上定义更复杂的访问控制逻辑。这比 URL 级别更灵活，因为它可以使用 SpEL (Spring Expression Language) 表达式。
    *   **应用场景**:
        *   **简单的角色检查**: `AdminController` 整个类被 `@PreAuthorize("hasRole('ADMIN')")` 标注，确保只有管理员能访问其中的所有 API。
        *   **动态的、基于业务逻辑的检查**: 这是该系统权限控制的一大亮点。例如：
            *   在 `TaskController.getTaskById()` 方法上，权限是 `@PreAuthorize("@workflowService.isTaskOwner(#camundaTaskId, principal.username) or hasRole('ADMIN')")`。
            *   **解读**: 这个表达式意味着，只有**当前任务的办理人**（通过调用 `workflowService.isTaskOwner` 方法判断）或者**系统管理员**才能访问这个任务的详情。这实现了对自己任务的精细化控制。
            *   类似地，`WorkflowController.getWorkflowHistory()` 也使用了复杂的 SpEL 表达式，允许多种角色（流程发起人、历史审批人、管理员）查看流程历史。

---

### 第三层：数据范围 (Data Scoping) - “你能看到哪些数据？”

这是最精细的一层权限控制，它解决了“两个用户拥有相同角色，但应该看到不同数据”的问题。例如，A 部门的经理和 B 部门的经理都能访问“部门报销列表”页面，但 A 经理只能看到 A 部门的报销单，B 经理只能看到 B 部门的。

*   **配置入口**: `domain/Menu.java` 实体中新增了 `dataScope` 字段，其类型为 `DataScope` 枚举。
*   **`DataScope` 枚举**: 定义了数据可见范围的几种策略：
    *   `ALL`: 查看所有数据（通常仅限管理员）。
    *   `BY_DEPARTMENT`: 仅查看本部门的数据。
    *   `BY_GROUP`: 仅查看本用户组的数据。
    *   `OWNER_ONLY`: 仅查看自己提交的数据。
*   **实现逻辑**:
    *   **核心代码**: `service/FormService.java` 中的 `applyDataScope` 方法。
    *   **工作流程**:
        1.  当用户通过某个菜单访问数据列表页面时（如 `/api/forms/{formId}/submissions`），会附带上 `menuId` 参数。
        2.  `FormService` 根据 `menuId` 查找到对应的 `Menu` 实体，并获取其 `dataScope` 配置。
        3.  `applyDataScope` 方法会根据 `dataScope` 的值，动态地向 JPA 查询中添加 `WHERE` 条件。
        4.  例如，如果 `dataScope` 是 `BY_DEPARTMENT`，它会构建一个子查询，添加类似 `WHERE submitter_id IN (SELECT user_id FROM app_user WHERE department_id = '当前用户的部门ID')` 的条件。
        5.  这样，最终执行的 SQL 查询本身就包含了数据过滤逻辑，从数据库层面保证了用户只能获取到他们有权查看的数据。

### 总结

下表总结了系统的多层权限体系：

| 层面 | 目的 | 实现技术/关键代码 | 示例 |
| :--- | :--- | :--- | :--- |
| **认证 (Authentication)** | 确认用户是谁 | Spring Security, JWT, `JwtAuthFilter`, `UserDetailsServiceImpl` | 用户名密码登录，生成 Token，后续请求携带 Token。 |
| **授权 (Authorization)** | 决定用户能做什么 | **URL级**: `SecurityConfig` <br> **方法级**: `@PreAuthorize` 注解 | 只有 ADMIN 角色能访问 `/api/admin/**` 路径。只有任务的办理人才能完成该任务。 |
| **数据范围 (Data Scoping)** | 决定用户能看到哪些数据 | `Menu.dataScope` 字段, JPA Specification, `FormService.applyDataScope` | 部门经理只能看到本部门员工提交的申请单。 |

这种分层设计使得权限逻辑清晰、易于扩展，并提供了从宏观到微观的全面安全保障。